{"version":3,"sources":["../../dist/Roboto-Regular~VGPWxChw.png","../../src/utils.js","../../src/TextGeometry.jsx","../../src/fonts/roboto/Roboto-Regular.png","../../src/shaders.js","../../src/Text.jsx","App.js","index.js"],"names":["module","exports","bounds","positions","box","min","max","count","i","x","y","Math","computeBox","computeBoundingSphere","sphere","minX","minY","width","height","length","radius","computeSphere","isNaN","console","TextGeometry","props","lineHeight","letterSpacing","multipage","flipY","tabSize","mode","start","end","align","hasBackground","hasBorders","borderRadius","borderWidth","borderBuffer","glyphs","useMemo","layoutProps","createLayout","layout","glyph","getGlyphs","hasBack","extras","Float32Array","bitmap","w","h","maxBorder","borderSize","offset","borderBox","boxes","side","getPositions","uvs","texWidth","font","texHeight","extra","partId","bw","bh","u0","v1","u1","v0","getUvs","index","indices","createIndices","clockwise","type","getIndexAttribute","pages","id","getPages","update","useCallback","self","computeBoundingBox","attachObject","array","itemSize","require","Text","text","alignment","textColor","textAlpha","backgroundColor","backgroundAlpha","borderColor","borderAlpha","borderSmoothing","fontSize","fontData","textureData","anchorVert","anchorHorz","positionVert","positionHorz","texture","useLoader","uniforms","textColorArray","borderColorArray","backgroundColorArray","value","map","viewport","useThree","scale","adjustedTextWidth","userData","anchorOffset","placementOffset","position","name","onUpdate","attach","args","transparent","vertexShader","fragmentShader","App","style","fallback","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.149aa386.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/Roboto-Regular~VGPWxChw.ab012798.png\";","import * as THREE from 'three'\nimport createIndices from 'quad-indices'\nimport createLayout from 'layout-bmfont-text'\n\n// finds the bounds that will hold the array of positions\nconst bounds = (positions) => {\n  const itemSize = 2\n  const box = {\n    min: [positions[0], positions[1]],\n    max: [positions[0], positions[1]],\n  }\n\n  const count = positions.length / itemSize\n\n  for (let i = 0; i < count; i++) {\n    const x = positions[i * itemSize + 0]\n    const y = positions[i * itemSize + 1]\n    box.min[0] = Math.min(x, box.min[0])\n    box.min[1] = Math.min(y, box.min[1])\n    box.max[0] = Math.max(x, box.max[0])\n    box.max[1] = Math.max(y, box.max[1])\n  }\n  return box\n}\n\n// get the minimum box that can hold the positions\nconst computeBox = (positions) => {\n  const box = bounds(positions)\n  const min = new THREE.Vector3(box.min[0], box.min[1], 0)\n  const max = new THREE.Vector3(box.max[0], box.max[1], 0)\n  return { min, max }\n}\n\n// get the minimum sphere that will hold the postions\nconst computeSphere = (positions) => {\n  const box = bounds(positions)\n  const minX = box.min[0]\n  const minY = box.min[1]\n  const maxX = box.max[0]\n  const maxY = box.max[1]\n  const width = maxX - minX\n  const height = maxY - minY\n  const length = Math.sqrt(width * width + height * height)\n\n  const center = new THREE.Vector3(minX + width / 2, minY + height / 2, 0)\n  const radius = length / 2\n  return { center, radius }\n}\n\n// get the UV texture mapping for the text. Also adds in magic numbers for drawing border and background if requested.\nexport const getUvs = (\n  glyphs,\n  texWidth,\n  texHeight,\n  flipY,\n  hasBack = false,\n  hasBorders = false\n) => {\n  const extras = (hasBack ? 1 : 0) + (hasBorders ? 8 : 0)\n  var uvs = new Float32Array((glyphs.length + extras) * 4 * 2)\n\n  var i = 0\n\n  // We use negative uvs values to inform the shader which part of the background is being rendered.\n  const offset = hasBack ? 0 : 1 // offset to keep partIds consistent even when background is not used\n  for (var extra = offset; extra < extras + offset; extra++) {\n    const partId = extra * -2.0 - 1.0 // -1, -3, -5, ...\n    // BL\n    uvs[i++] = partId - 1.0\n    uvs[i++] = partId\n    // TL\n    uvs[i++] = partId - 1.0\n    uvs[i++] = partId - 1.0\n    // TR\n    uvs[i++] = partId\n    uvs[i++] = partId - 1.0\n    // BR\n    uvs[i++] = partId\n    uvs[i++] = partId\n  }\n\n  glyphs.forEach((glyph) => {\n    var bitmap = glyph.data\n    var bw = bitmap.x + bitmap.width\n    var bh = bitmap.y + bitmap.height\n\n    // top left position\n    var u0 = bitmap.x / texWidth\n    var v1 = bitmap.y / texHeight\n    var u1 = bw / texWidth\n    var v0 = bh / texHeight\n\n    if (flipY) {\n      v1 = (texHeight - bitmap.y) / texHeight\n      v0 = (texHeight - bh) / texHeight\n    }\n\n    // BL\n    uvs[i++] = u0\n    uvs[i++] = v1\n    // TL\n    uvs[i++] = u0\n    uvs[i++] = v0\n    // TR\n    uvs[i++] = u1\n    uvs[i++] = v0\n    // BR\n    uvs[i++] = u1\n    uvs[i++] = v1\n  })\n\n  return uvs\n}\n\n// get the geometric postions for the text, background and borders.\nexport const getPositions = (\n  glyphs,\n  hasBack = false,\n  hasBorders = false,\n  borderRadius = 0,\n  borderWidth = 0,\n  borderBuffer = 0\n) => {\n  const size = 4 * 2\n  const extras = (hasBack ? 1 : 0) + (hasBorders ? 8 : 0)\n  var positions = new Float32Array((glyphs.length + extras) * size)\n  var i = extras * size\n\n  glyphs.forEach(function (glyph) {\n    var bitmap = glyph.data\n\n    // bottom left position\n    var x = glyph.position[0] + bitmap.xoffset\n    var y = glyph.position[1] + bitmap.yoffset\n\n    // quad size\n    var w = bitmap.width\n    var h = bitmap.height\n\n    // BL\n    positions[i++] = x\n    positions[i++] = y\n    // TL\n    positions[i++] = x\n    positions[i++] = y + h\n    // TR\n    positions[i++] = x + w\n    positions[i++] = y + h\n    // BR\n    positions[i++] = x + w\n    positions[i++] = y\n  })\n\n  // For the background and borders, we create 9 boxes. The corner boxes are squares so that the rounded border is always circular.\n  // The boxes on the edges hold the straight portions of the border on their outside edge. The center is just he backgound.\n  if (hasBack || hasBorders) {\n    // Get the dimensions of the text box without borders\n    const { min, max } = computeBox(positions.slice(extras * size))\n\n    // Limit the border to total size so that the border geometry doesn't overlap\n    const maxBorder = Math.min(max.x - min.x, max.y - min.y) / 2 + borderBuffer\n    const radius = Math.min(borderRadius, maxBorder)\n    const width = Math.min(borderWidth, maxBorder)\n    const borderSize = Math.max(radius, width)\n\n    const offset = borderBuffer - borderSize\n    i = 0\n    if (hasBack) {\n      // BL\n      positions[i++] = min.x - offset\n      positions[i++] = min.y - offset\n      // TL\n      positions[i++] = min.x - offset\n      positions[i++] = max.y + offset\n      // TR\n      positions[i++] = max.x + offset\n      positions[i++] = max.y + offset\n      // BR\n      positions[i++] = max.x + offset\n      positions[i++] = min.y - offset\n    }\n\n    if (hasBorders) {\n      const borderBox = {\n        min: { x: min.x - offset, y: min.y - offset },\n        max: { x: max.x + offset, y: max.y + offset },\n      }\n      const boxes = [\n        {\n          // TOP\n          min: { x: borderBox.min.x, y: borderBox.min.y - borderSize },\n          max: { x: borderBox.max.x, y: borderBox.min.y },\n        },\n        {\n          // LEFT\n          min: { x: borderBox.min.x - borderSize, y: borderBox.min.y },\n          max: { x: borderBox.min.x, y: borderBox.max.y },\n        },\n        {\n          // BOTTOM\n          min: { x: borderBox.min.x, y: borderBox.max.y },\n          max: { x: borderBox.max.x, y: borderBox.max.y + borderSize },\n        },\n        {\n          // RIGHT\n          min: { x: borderBox.max.x, y: borderBox.min.y },\n          max: { x: borderBox.max.x + borderSize, y: borderBox.max.y },\n        },\n        {\n          // TOP/LEFT\n          min: {\n            x: borderBox.min.x - borderSize,\n            y: borderBox.min.y - borderSize,\n          },\n          max: { x: borderBox.min.x, y: borderBox.min.y },\n        },\n        {\n          // LEFT/BOTTOM\n          min: { x: borderBox.min.x - borderSize, y: borderBox.max.y },\n          max: { x: borderBox.min.x, y: borderBox.max.y + borderSize },\n        },\n        {\n          // BOTTOM/RIGHT\n          min: { x: borderBox.max.x, y: borderBox.max.y },\n          max: {\n            x: borderBox.max.x + borderSize,\n            y: borderBox.max.y + borderSize,\n          },\n        },\n        {\n          // RIGHT/ TOP\n          min: { x: borderBox.max.x, y: borderBox.min.y - borderSize },\n          max: { x: borderBox.max.x + borderSize, y: borderBox.min.y },\n        },\n      ]\n      for (var side = 0; side < 8; side++) {\n        // BL\n        positions[i++] = boxes[side].min.x\n        positions[i++] = boxes[side].min.y\n        // TL\n        positions[i++] = boxes[side].min.x\n        positions[i++] = boxes[side].max.y\n        // TR\n        positions[i++] = boxes[side].max.x\n        positions[i++] = boxes[side].max.y\n        // BR\n        positions[i++] = boxes[side].max.x\n        positions[i++] = boxes[side].min.y\n      }\n    }\n  }\n\n  return positions\n}\n\n// get the glyphs that represent the text once it has been layed out\nexport const getGlyphs = (\n  font,\n  text,\n  width,\n  align,\n  lineHeight,\n  letterSpacing,\n  tabSize,\n  mode,\n  start,\n  end\n) => {\n  const layoutProps = {\n    font,\n    text,\n    width,\n    align,\n    lineHeight,\n    letterSpacing,\n    tabSize,\n    mode,\n    start,\n    end,\n  }\n  const layout = createLayout(layoutProps)\n  const glyphs = layout.glyphs.filter(\n    (glyph) => glyph.data.width * glyph.data.height > 0\n  )\n  return glyphs\n}\n\nexport const getPages = (glyphs) => {\n  const pages = new Float32Array(glyphs.length * 4 * 1)\n  let i = 0\n  glyphs.forEach(function (glyph) {\n    const id = glyph.data.page || 0\n    pages[i++] = id\n    pages[i++] = id\n    pages[i++] = id\n    pages[i++] = id\n  })\n  return pages\n}\n\nexport const getIndexAttribute = (\n  length,\n  hasBack = false,\n  hasBorders = false\n) => {\n  const extras = (hasBack ? 1 : 0) + (hasBorders ? 8 : 0)\n  var indices = createIndices({\n    clockwise: true,\n    type: 'uint16',\n    count: length + extras,\n  })\n\n  const index = new THREE.BufferAttribute(indices, 1)\n  return index\n}\n\nexport const computeBoundingSphere = (positions) => {\n  if (!positions || positions.length < 2) {\n    return new THREE.Sphere([0, 0, 0], 0)\n  }\n  const sphere = computeSphere(positions)\n  if (isNaN(sphere.radius)) {\n    console.error(\n      'THREE.BufferGeometry.computeBoundingSphere(): ' +\n        'Computed radius is NaN. The ' +\n        '\"position\" attribute is likely to have NaN values.'\n    )\n  }\n  return new THREE.Sphere(sphere.center, sphere.radius)\n}\n\nexport const computeBoundingBox = (positions) => {\n  if (!positions || positions.length < 2) {\n    return new THREE.Box3().makeEmpty()\n  }\n  const box = computeBox(positions)\n  return new THREE.Box3(box.min, box.max)\n}\n","import React, { useMemo, useCallback, Fragment } from 'react'\nimport {\n  computeBoundingBox,\n  computeBoundingSphere,\n  getGlyphs,\n  getIndexAttribute,\n  getPages,\n  getPositions,\n  getUvs,\n} from './utils'\n\n// Creates the geometry for the text, background, and borders\nconst TextGeometry = (props) => {\n  const {\n    font, // Required\n    text,\n    width,\n    lineHeight = null,\n    letterSpacing = null,\n    multipage = false,\n    flipY = true,\n    tabSize = null,\n    mode = null, // 'nowrap', 'pre'\n    start = null,\n    end = null,\n    align = null, // 'left', 'right', 'center'\n    hasBackground = false,\n    hasBorders = false,\n    borderRadius = 0,\n    borderWidth = 0,\n    borderBuffer = 0,\n  } = props\n\n  // Array of glyphs for the text\n  const glyphs = useMemo(\n    () =>\n      getGlyphs(\n        font,\n        text,\n        width,\n        align,\n        lineHeight,\n        letterSpacing,\n        tabSize,\n        mode,\n        start,\n        end\n      ),\n    [\n      align,\n      end,\n      font,\n      letterSpacing,\n      lineHeight,\n      mode,\n      start,\n      tabSize,\n      text,\n      width,\n    ]\n  )\n\n  // Geometeric positions of the text background and borders\n  const positions = useMemo(\n    () =>\n      getPositions(\n        glyphs,\n        hasBackground,\n        hasBorders,\n        borderRadius,\n        borderWidth,\n        borderBuffer\n      ),\n    [borderBuffer, borderRadius, borderWidth, glyphs, hasBackground, hasBorders]\n  )\n\n  // Textile postions used for retrieving data from the font texture and determining how to color the background and borders\n  const uvs = useMemo(() => {\n    const texWidth = font.common.scaleW\n    const texHeight = font.common.scaleH\n    const uvs = getUvs(\n      glyphs,\n      texWidth,\n      texHeight,\n      flipY,\n      hasBackground,\n      hasBorders\n    )\n    return uvs\n  }, [\n    flipY,\n    font.common.scaleH,\n    font.common.scaleW,\n    glyphs,\n    hasBackground,\n    hasBorders,\n  ])\n\n  const index = useMemo(() => {\n    return getIndexAttribute(glyphs.length, hasBackground, hasBorders)\n  }, [glyphs.length, hasBackground, hasBorders])\n\n  const pages = useMemo(() => {\n    return getPages(glyphs)\n  }, [glyphs])\n\n  const update = useCallback((self) => {\n    self.boundingBox = computeBoundingBox(self.attributes.position.array)\n    self.boundingSphere = computeBoundingSphere(self.attributes.position.array)\n\n    self.attributes.position.needsUpdate = true\n    self.attributes.uv.needsUpdate = true\n  }, [])\n\n  return (\n    <bufferGeometry\n      name='TextGeometry'\n      index={index}\n      onUpdate={update}\n      {...props}\n    >\n      {multipage ? (\n        <bufferAttribute\n          attachObject={['attributes', 'page']}\n          array={pages}\n          itemSize={1}\n        />\n      ) : (\n        <Fragment />\n      )}\n      <bufferAttribute\n        attachObject={['attributes', 'position']}\n        array={positions}\n        itemSize={2}\n      />\n      <bufferAttribute\n        attachObject={['attributes', 'uv']}\n        array={uvs}\n        itemSize={2}\n      />\n    </bufferGeometry>\n  )\n}\n\nexport default TextGeometry\n","/* loaded by smart-asset */\nexport default require(\"./Roboto-Regular~VGPWxChw.png\")","export const vertex = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);\n  }\n  `\nexport const fragment = `\n  #ifdef GL_OES_standard_derivatives\n  #extension GL_OES_standard_derivatives : enable\n  #endif\n\n  precision highp float;\n  uniform vec4 textColor;\n  uniform vec4 backgroundColor;\n  uniform vec4 borderColor;\n  uniform float borderWidth; \n  uniform float borderRadius;\n  uniform float borderSmoothing;\n  uniform sampler2D map;\n  varying vec2 vUv;\n  \n  // Subtractive smoothing smooths the existing border edges vs adding more pixels to the border that are smoothed.\n  const bool subtractiveSmoothing = true;\n\n  float borderSize = max(borderWidth, borderRadius);\n  float borderWidthPct = borderSize > 0.0 ? borderWidth/borderSize : 0.0;\n  float borderRadiusPct = borderSize > 0.0 ? borderRadius/borderSize : 0.0;\n\n  float median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n  }\n\n  vec4 border(float dist) {\n    vec4 empty = vec4(0., 0., 0., 0.);\n\n    float outer = borderSmoothing > 0.0 \n      ? (\n        subtractiveSmoothing \n          ? smoothstep(0.0, 0.0 + borderSmoothing, 1.0 - dist) \n          : smoothstep(-borderSmoothing, 0.0, 1.0 - dist - borderSmoothing)\n      )\n      : step(0.0, 1.0 - dist); // Outside border - no smoothing\n\n    float inner = borderSmoothing > 0.0 \n      ? (\n        subtractiveSmoothing \n          ? smoothstep(1.0, 1.0 + borderSmoothing, dist + borderWidthPct) \n          : smoothstep(1.0 - borderSmoothing, 1.0, dist + borderWidthPct)\n      )\n      : step(1.0, dist + borderWidthPct); // Inside border - no smoothing\n    \n    vec4 innerMix = mix(backgroundColor, borderColor, inner); // Colors the inside like the background and everything else like the border\n    vec4 fullMix = mix(empty, innerMix, outer); // Colors everything ouside the outer border transparent\n    return fullMix;\n  }\n\n  // Draws an 1/4 circle arc. \n  // The insideCorner sets the corner that is on the inside of the border. This should be one of the corners [0,0], [0,1], [1,0], [1,1].\n  vec4 arc(vec2 uv, vec2 insideCorner){\n    vec2 center = abs(insideCorner - 1.0 + borderRadiusPct);\n    vec2 cornerCenterDiff = abs(insideCorner - center);\n    vec2 cornerPointDiff = abs(insideCorner - uv);\n    float pointDistance = distance(center, insideCorner);\n    // Check if the point is in the square that the arc is rendered. \n    if(cornerCenterDiff.x <= cornerPointDiff.x && cornerCenterDiff.y <= cornerPointDiff.y){\n      // Use the distance from the \"center\" point plus the centers offfset from the corner as the border distance.\n      float centerDist = distance(uv, center) + cornerCenterDiff.x;\n      return border(centerDist);\n    }else{\n      // Draw the line border when the point is outside the arc square. This applies when the border radius is less than the border width.\n      float linearDist = max(cornerPointDiff.x, cornerPointDiff.y);\n      return border(linearDist);\n    }\n  }\n\n  // Draws a vertical or horizontal border on the outer edge of the unit.\n  // The edge describes which edge to draw the border against.\n  //   [-1,0] will draw the border against left edge. \n  //   [1,0] right edge.\n  //   [0,-1] top edge.\n  //   [0,1] bottom edge.\n  vec4 line(vec2 uv, vec2 edge){\n    float dist = 0.0;\n    if(edge.x != 0.0){ // This is a vertical border\n      dist = edge.x > 0.0 ? uv.x : 1.0 - uv.x;\n    }\n    \n    if(edge.y != 0.0){ // This is a horizontal border\n      dist = edge.y > 0.0 ? uv.y : 1.0 - uv.y;\n    }\n\n    return border(dist);\n  }\n  \n  void main() {\n    if(vUv.x < 0.0 && vUv.y < 0.0) { // We are dealing with one of the background/border components\n      float BG = -2.0;\n      float T = -4.0;\n      float L = -6.0;\n      float B = -8.0;\n      float R = -10.0;\n      float TL = -12.0;\n      float BL = -14.0;\n      float BR = -16.0;\n      float TR = -18.0;\n      float sigma = 0.5; // increase the uv capture range to make sure we draw all the pixels\n\n      // Background\n      if(vUv.x >= BG - sigma && vUv.y >= BG - sigma) {\n        gl_FragColor = backgroundColor;\n      } \n\n      // Vert/Horz Borders \n      else if(vUv.x >= T - sigma && vUv.y >= T - sigma) { // Top\n        gl_FragColor = line(vUv - vec2(T), vec2(0.0, 1.0));\n      } else if(vUv.x >= L - sigma && vUv.y >= L - sigma) { // Left\n        gl_FragColor = line(vUv - vec2(L), vec2(-1.0, 0.0));\n      } else if(vUv.x >= B - sigma && vUv.y >= B - sigma) { // Bottom\n        gl_FragColor = line(vUv - vec2(B), vec2(0.0, -1.0));\n      } else if(vUv.x >= R - sigma && vUv.y >= R - sigma) { // Right\n        gl_FragColor = line(vUv - vec2(R), vec2(1.0, 0.0));\n      } \n\n      // Corner Borders\n      else if(vUv.x >= TL - sigma && vUv.y >= TL - sigma) { // Top/Left\n        gl_FragColor = arc(vUv - vec2(TL), vec2(1.0, 0.0));\n      } else if(vUv.x >= BL - sigma && vUv.y >= BL - sigma) { // Left/Bottom\n        gl_FragColor = arc(vUv - vec2(BL), vec2(1.0, 1.0));\n      } else if(vUv.x >= BR - sigma && vUv.y >= BR - sigma) { // Bottom/Right\n        gl_FragColor = arc(vUv - vec2(BR), vec2(0.0, 1.0));\n      } else { // if(vUv.x >= TR - sigma && vUv.y >= TR - sigma) { // Right/Top\n        gl_FragColor = arc(vUv - vec2(TR), vec2(0.0, 0.0));\n      }\n    } else { \n      // This is where we draw the text from the msdf texture\n      vec3 sample = 1.0 - texture2D(map, vUv).rgb;\n      float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n      float alpha = clamp(sigDist/fwidth(sigDist) + 0.5, 0.0, 1.0);\n      \n      gl_FragColor = vec4(textColor.xyz, textColor.w * alpha);\n    }\n  }\n  `\n","import React, { useMemo, useCallback } from 'react'\nimport { useLoader, useThree } from 'react-three-fiber'\nimport * as THREE from 'three'\nimport TextGeometry from './TextGeometry'\nimport robotoFont from './fonts/roboto/Roboto-Regular.json'\nimport robotoTexture from './fonts/roboto/Roboto-Regular.png'\nimport { vertex, fragment } from './shaders'\n\nexport const TOP = 'top'\nexport const LEFT = 'left'\nexport const CENTER = 'center'\nexport const BOTTOM = 'bottom'\nexport const RIGHT = 'right'\n\n/**\n * Displays the disired text with background and border using the supplied msdf (Multi-Signed Distance Fields) font.\n * text: string\n * width: percentage of viewport width - defaults to 100 (full width)\n * alignment: text alignment when there is a width <LEFT, CENTER, RIGHT> - defaults to 'CENTER'\n * textColor: hexadecimal triplet or CSS-style string for the color - defaults to black\n * textAlpha: alpha value of 0.0 to 1.0 - defaults to 1.0 (opaque)\n * backgroundColor: hexadecimal triplet or CSS-style string for the color - defaults to black\n * backgroundAlpha: alpha value of 0.0 to 1.0 - defaults to 0.0 (transparent)\n * borderColor: hexadecimal triplet or CSS-style string for the color - defaults to black\n * borderAlpha: alpha value of 0.0 to 1.0 - defaults to 0.0 (transparent)\n * borderWidth: width of the border area to fill in - defaults to 0\n * borderSmoothing: fraction portion of the border to smooth - defaults to 0\n * borderRadius: radius for the corners - defaults to 0,\n * borderBuffer: extra padding to add onto the background (mostly so the border doesn't draw over the text) - defaults to 0,\n * fontSize: numeric pixel size of font - defaults to 12\n * fontData: json font definition date - defaults to roboto-regular\n * textureData: png font texture date - deafaults to roboto-regular\n * anchorVert, anchorHorz: The anchor point of the text object that will be placed at the placement point - defaults to the center\n * positionVert, positionHorz: Percentage of viewport between the anchor and the top/left - defaults to the center of the viewport\n */\nexport const Text = ({\n  text = '',\n  width = 100,\n  alignment = CENTER,\n  textColor = 0x000000,\n  textAlpha = 1.0,\n  backgroundColor = 0x000000,\n  backgroundAlpha = 0.0,\n  borderColor = 0x000000,\n  borderAlpha = 0.0,\n  borderWidth = 0,\n  borderSmoothing = 0,\n  borderRadius = 0,\n  borderBuffer = 0,\n  fontSize = 12,\n  fontData = robotoFont,\n  textureData = robotoTexture,\n  anchorVert = CENTER,\n  anchorHorz = CENTER,\n  positionVert = 50,\n  positionHorz = 50,\n}) => {\n  // Font Data\n  const font = useMemo(() => {\n    return new THREE.Font(fontData)\n  }, [fontData])\n\n  const hasBackground = useMemo(() => backgroundAlpha > 0, [backgroundAlpha])\n  const hasBorders = useMemo(() => borderRadius > 0 || borderWidth > 0, [\n    borderRadius,\n    borderWidth,\n  ])\n\n  // Texture Data\n  const texture = useLoader(THREE.TextureLoader, textureData)\n\n  // Uniforms for shader\n  const uniforms = useMemo(() => {\n    const textColorArray = new THREE.Color(textColor).toArray()\n    textColorArray.push(textAlpha)\n    const borderColorArray = new THREE.Color(borderColor).toArray()\n    borderColorArray.push(borderAlpha)\n    const backgroundColorArray = new THREE.Color(backgroundColor).toArray()\n    backgroundColorArray.push(backgroundAlpha)\n\n    const uniforms = {\n      textColor: { value: textColorArray },\n      backgroundColor: { value: backgroundColorArray },\n      borderColor: { value: borderColorArray },\n      borderWidth: { value: borderWidth },\n      borderRadius: { value: borderRadius },\n      borderSmoothing: { value: borderSmoothing },\n      map: { value: texture },\n    }\n    return uniforms\n  }, [\n    textColor,\n    textAlpha,\n    backgroundColor,\n    backgroundAlpha,\n    borderColor,\n    borderAlpha,\n    borderWidth,\n    borderRadius,\n    borderSmoothing,\n    texture,\n  ])\n\n  // Retrieve the viewport from the rendering engine\n  const { viewport } = useThree()\n\n  // Calculate the scale of the font using the viewport factor\n  const scale = useMemo(() => {\n    const view = 1 / viewport.factor\n    return (view / font.data.info.size) * fontSize\n  }, [font.data.info.size, fontSize, viewport.factor])\n\n  // Calculate the desired width of the text (for wrapping) based on the \"width\" prop (percentage of the screen width)\n  const adjustedTextWidth = useMemo(() => {\n    return ((viewport.width / scale) * width) / 100\n  }, [scale, viewport.width, width])\n\n  // Create userData based on the text so that the screen will update if the text changes\n  const userData = useMemo(() => {\n    return { text }\n  }, [text])\n\n  // Called whenever the mesh updates. Here we calculate and set the postion of the text.\n  const update = useCallback(\n    (self) => {\n      const box = self.geometry.boundingBox\n      const sphere = self.geometry.boundingSphere\n\n      const anchorOffset = {\n        x:\n          anchorHorz === LEFT\n            ? -box.min.x\n            : anchorHorz === CENTER\n            ? -sphere.center.x\n            : anchorHorz === RIGHT\n            ? -box.max.x\n            : 0,\n        y:\n          anchorVert === TOP\n            ? box.min.y\n            : anchorVert === CENTER\n            ? sphere.center.y\n            : anchorVert === BOTTOM\n            ? box.max.y\n            : 0,\n      }\n\n      const placementOffset = {\n        x: (viewport.width * positionHorz) / 100 - viewport.width / 2,\n        y: viewport.height / 2 - (viewport.height * positionVert) / 100,\n      }\n\n      const position = [\n        anchorOffset.x * scale + placementOffset.x,\n        anchorOffset.y * scale + placementOffset.y,\n        0,\n      ]\n\n      self.scale.set(scale, scale, scale)\n      self.position.set(...position)\n      self.rotation.set(Math.PI, 0, 0)\n    },\n    [\n      anchorHorz,\n      anchorVert,\n      positionHorz,\n      positionVert,\n      scale,\n      viewport.height,\n      viewport.width,\n    ]\n  )\n\n  return (\n    <mesh name='Text' onUpdate={update} userData={userData}>\n      <TextGeometry\n        attach='geometry'\n        text={text}\n        width={adjustedTextWidth}\n        align={alignment}\n        font={font.data}\n        borderRadius={borderRadius}\n        borderWidth={borderWidth}\n        borderBuffer={borderBuffer}\n        hasBackground={hasBackground}\n        hasBorders={hasBorders}\n      />\n      <shaderMaterial\n        attach='material'\n        args={[\n          {\n            transparent: true,\n            vertexShader: vertex,\n            fragmentShader: fragment,\n            uniforms,\n          },\n        ]}\n      />\n    </mesh>\n  )\n}\n","import React, {Suspense} from 'react'\nimport { Canvas } from 'react-three-fiber'\nimport { Text, CENTER } from 'react-msdf-text'\n\nconst App = () => {\n  return (\n    <Canvas style={{ width: \"100vw\", height: \"100vh\" }}>\n      <Suspense fallback={<></>}>\n        <Text\n          text={'Here is an example of high quality MSDF text. The text will wrap at the edges. The font color, font size, and backgound color are all configureable. The border color, width, blend, radius are also configurable.'}\n          positionVert={50}\n          anchorVert={CENTER}\n          width={80}\n          fontSize={50}\n          textColor={0x0E0E0E}\n          backgroundColor={'hsl(0, 100%, 50%)'}\n          backgroundAlpha={.8}\n          borderColor={'skyblue'}\n          borderAlpha={.9}\n          borderWidth={5}\n          borderRadius={10}\n          borderSmoothing={0.1}\n          borderBuffer={3}\n        />\n      </Suspense>\n    </Canvas>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}